jest.mock('@vx/libs/utils/src', (): typeof import('@vx/libs/utils/src') => {
  return {
    ...jest.requireActual('@vx/libs/utils/src'),
    isFeatureFlagEnabled: (flag) => mockFeatureFlagger.isEnabled(flag),
  };
});

jest.mock('../../ballot-styles/ballot_style_reports');

jest.mock('@vx/libs/hmpb/src', () => {
  const original = jest.requireActual('@vx/libs/hmpb/src');
  return {
    ...original,
    renderAllBallotsAndCreateElectionDefinition: jest.fn(
      original.renderAllBallotsAndCreateElectionDefinition
    ),
  };
});

import { Buffer } from 'node:buffer';
import JsZip from 'jszip';
import { find } from '@vx/libs/basics/collections';
import { electionFamousNames2021Fixtures } from '@vx/libs/fixtures/src';
import {
  BallotType,
  type Election,
  LanguageCode,
  type UiStringsPackage,
  mergeUiStrings,
} from '@vx/libs/types/src';
import {
  BooleanEnvironmentVariableName,
  getFeatureFlagMock,
} from '@vx/libs/utils/src';
import { mockOf } from '@vx/libs/test-utils/src';
import {
  type BallotMode,
  type BaseBallotProps,
  hmpbStringsCatalog,
  renderAllBallotsAndCreateElectionDefinition,
  vxDefaultBallotTemplate,
} from '@vx/libs/hmpb/src';
import { testSetupHelpers } from '../../test/helpers';
import { renderBallotStyleReadinessReport } from '../../ballot-styles/ballot_style_reports';
import { BALLOT_STYLE_READINESS_REPORT_FILE_NAME } from '../../app/app';

jest.setTimeout(60_000);

const mockFeatureFlagger = getFeatureFlagMock();

const { setupApp, cleanup } = testSetupHelpers();

const MOCK_READINESS_REPORT_CONTENTS = '%PDF - MockReadinessReport';
const MOCK_READINESS_REPORT_PDF = Buffer.from(
  MOCK_READINESS_REPORT_CONTENTS,
  'utf-8'
);

function expectedEnglishBallotStrings(election: Election): UiStringsPackage {
  const expectedStrings = mergeUiStrings(election.ballotStrings, {
    [LanguageCode.ENGLISH]: hmpbStringsCatalog,
  });
  // Ballot style IDs are generated by VxDesign and then translated
  expectedStrings[LanguageCode.ENGLISH]!['ballotStyleId'] = Object.fromEntries(
    election.ballotStyles.map(({ id, groupId }) => [id, groupId])
  );
  return expectedStrings;
}

afterAll(cleanup);

beforeEach(() => {
  mockFeatureFlagger.resetFeatureFlags();
  mockFeatureFlagger.enableFeatureFlag(
    BooleanEnvironmentVariableName.ENABLE_CLOUD_TRANSLATION_AND_SPEECH_SYNTHESIS
  );

  mockOf(renderBallotStyleReadinessReport).mockResolvedValue(
    MOCK_READINESS_REPORT_PDF
  );
});

test('Export all ballots', async () => {
  // This test runs unnecessarily long if we're generating exports for all
  // languages, so disabling multi-language support for this case:
  mockFeatureFlagger.disableFeatureFlag(
    BooleanEnvironmentVariableName.ENABLE_CLOUD_TRANSLATION_AND_SPEECH_SYNTHESIS
  );

  const baseElectionDefinition =
    electionFamousNames2021Fixtures.electionDefinition;
  const { apiClient } = setupApp();

  const electionId = (
    await apiClient.loadElection({
      electionData: baseElectionDefinition.electionData,
    })
  ).unsafeUnwrap();
  const { ballotStyles, election, precincts } = await apiClient.getElection({
    electionId,
  });

  const { zipContents } = await apiClient.exportAllBallots({
    electionId,
    electionSerializationFormat: 'vxf',
  });
  const zip = await JsZip.loadAsync(zipContents);

  const expectedFileNames = [
    BALLOT_STYLE_READINESS_REPORT_FILE_NAME,
    ...ballotStyles
      .flatMap(({ id, precinctsOrSplits }) =>
        precinctsOrSplits.map((p) => ({
          ballotStyleId: id,
          precinctId: p.precinctId,
        }))
      )
      .flatMap(({ ballotStyleId, precinctId }) => {
        const precinctName = find(
          precincts,
          (p) => p.id === precinctId
        ).name.replaceAll(' ', '_');

        const suffix = `ballot-${precinctName}-${ballotStyleId}.pdf`;

        return [
          `official-precinct-${suffix}`,
          `test-precinct-${suffix}`,
          `sample-precinct-${suffix}`,
          `official-absentee-${suffix}`,
          `test-absentee-${suffix}`,
          `sample-absentee-${suffix}`,
        ];
      }),
  ].sort();
  expect(Object.keys(zip.files).sort()).toEqual(expectedFileNames);

  const readinessReportFileContents =
    await zip.files[BALLOT_STYLE_READINESS_REPORT_FILE_NAME].async('text');
  expect(readinessReportFileContents).toContain(MOCK_READINESS_REPORT_CONTENTS);

  // Ballot appearance is tested by fixtures in libs/hmpb, so we
  // just make sure we got a PDF and that we called the layout function with the
  // right arguments.
  for (const file of Object.values(zip.files)) {
    expect(await file.async('text')).toContain('%PDF');
  }
  expect(renderAllBallotsAndCreateElectionDefinition).toHaveBeenCalledTimes(1);
  const ballotCombos: Array<[BallotType, BallotMode]> = [
    [BallotType.Precinct, 'official'],
    [BallotType.Precinct, 'test'],
    [BallotType.Precinct, 'sample'],
    [BallotType.Absentee, 'official'],
    [BallotType.Absentee, 'test'],
    [BallotType.Absentee, 'sample'],
  ];
  const expectedBallotProps = election.ballotStyles.flatMap((ballotStyle) =>
    ballotStyle.precincts.flatMap((precinctId) =>
      ballotCombos.map(
        ([ballotType, ballotMode]): BaseBallotProps => ({
          election: {
            ...election,
            ballotStrings: expectedEnglishBallotStrings(election),
          },
          ballotStyleId: ballotStyle.id,
          precinctId,
          ballotType,
          ballotMode,
        })
      )
    )
  );
  expect(renderAllBallotsAndCreateElectionDefinition).toHaveBeenCalledWith(
    expect.any(Object), // Renderer
    vxDefaultBallotTemplate,
    expectedBallotProps,
    'vxf'
  );
});
