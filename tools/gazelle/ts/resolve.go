package ts

import (
	"log"
	"path"
	"slices"
	"strings"

	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/label"
	"github.com/bazelbuild/bazel-gazelle/repo"
	"github.com/bazelbuild/bazel-gazelle/resolve"
	"github.com/bazelbuild/bazel-gazelle/rule"
)

const (
	ambientTypesImportEnv                  = "types_env"
	ambientTypesImportJestStyledComponents = "types_jest_styled_components"
	ambientTypesImportKioskBrowser         = "types_kiosk_browser"
)

var (
	internalTypeDefinitionTargets = map[string]label.Label{
		ambientTypesImportEnv: {Name: "types_env"},
		ambientTypesImportJestStyledComponents: {
			Name: "types_jest_styled_components",
		},
		ambientTypesImportKioskBrowser: {Name: "types_kiosk_browser"},
		"compress-commons":             {Name: "types_compress_commons"},
		"node-quirc":                   {Name: "types_node_quirc"},
		"stream-chopper":               {Name: "types_stream_chopper"},
		"zip-stream":                   {Name: "types_zip_stream"},
	}
)

// Imports returns a list of ImportSpecs that can be used to import `buildRule`.
// This is used to populate RuleIndex.
//
// If nil is returned, the rule will not be indexed. If any non-nil slice is
// returned, including an empty slice, the rule will be indexed.
func (t *tsPackage) Imports(
	runConfig *config.Config,
	buildRule *rule.Rule,
	buildFile *rule.File,
) []resolve.ImportSpec {
	switch buildRule.Kind() {
	case tsLibraryKindName:
		fallthrough
	case tsTestsKindName:
		fallthrough
	case tsStoriesKindName:
		srcFiles, ok := buildRule.PrivateAttr("srcs").([]string)
		if !ok {
			log.Fatalf("malformed json_package rule - see generate.go\n")
		}

		return getImportSpecsForFiles(buildFile, srcFiles)

	case lintTestKindName:
		return []resolve.ImportSpec{}

	case jsonPackageKindName:
		jsonFiles, ok := buildRule.PrivateAttr("srcs").([]string)
		if !ok {
			log.Fatalf("malformed json_package rule - see generate.go\n")
			return nil
		}

		return getImportSpecsForFiles(buildFile, jsonFiles)

	default:
		panic("unexpected rule kind: " + buildRule.Kind())
	}
}

func getImportSpecsForFiles(
	buildFile *rule.File,
	fileNames []string,
) []resolve.ImportSpec {
	importSpecs := []resolve.ImportSpec{}

	for _, fileName := range fileNames {
		importSpecs = append(
			importSpecs,
			getImportSpecsForFile(buildFile, fileName)...,
		)
	}

	return importSpecs
}

func getImportSpecsForFile(
	buildFile *rule.File,
	fileName string,
) []resolve.ImportSpec {
	importSpecs := []resolve.ImportSpec{}

	workspaceRelativeDirectoryPath := path.Clean(buildFile.Pkg)
	workspaceRelativeFilePath := path.Clean(path.Join(
		workspaceRelativeDirectoryPath,
		fileName,
	))
	importSpecs = append(importSpecs, resolve.ImportSpec{
		Lang: languageName,
		Imp:  workspaceRelativeFilePath,
	})

	fileExtension := path.Ext(workspaceRelativeFilePath)
	if fileExtension == ".json" {
		// No aliases for JSON imports, since they need to be imported with their
		// extension included.
		return importSpecs
	}

	extensionlessFilePath := strings.TrimSuffix(
		workspaceRelativeFilePath,
		path.Ext(workspaceRelativeFilePath),
	)
	extensionlessFilePath = strings.TrimSuffix(extensionlessFilePath, ".d")

	importSpecs = append(importSpecs, resolve.ImportSpec{
		Lang: languageName,
		Imp:  extensionlessFilePath,
	})

	if path.Base(extensionlessFilePath) == "index" {
		importSpecs = append(importSpecs, resolve.ImportSpec{
			Lang: languageName,
			Imp:  path.Dir(extensionlessFilePath),
		})
	}

	return importSpecs
}

// Embeds returns a list of labels of rules that the given rule embeds. If
// a rule is embedded by another importable rule of the same language, only
// the embedding rule will be indexed. The embedding rule will inherit
// the imports of the embedded rule.
func (t *tsPackage) Embeds(r *rule.Rule, from label.Label) []label.Label {
	return []label.Label{}
}

// Resolve translates imported libraries for a given rule into Bazel
// dependencies. Information about imported libraries is returned for each
// rule generated by language.GenerateRules in
// language.GenerateResult.Imports. Resolve generates a "deps" attribute (or
// the appropriate language-specific equivalent) for each import according to
// language-specific rules and heuristics.
func (t *tsPackage) Resolve(
	runConfig *config.Config,
	ruleIndex *resolve.RuleIndex,
	remoteCache *repo.RemoteCache,
	buildRule *rule.Rule,
	imports interface{},
	buildRuleLabel label.Label,
) {
	switch buildRule.Kind() {
	case tsLibraryKindName:
		fallthrough
	case tsStoriesKindName:
		fallthrough
	case tsTestsKindName:
		jsImports, ok := imports.(JsImports)
		if !ok {
			panic("unable to extract imports for " + tsTestsKindName + " rule")
		}

		setDeps(
			runConfig,
			buildRule,
			"deps",
			ruleIndex,
			buildRuleLabel,
			jsImports,
		)

	case lintTestKindName:
		// no-op

	case jsonPackageKindName:
		// no-op

	default:
		panic("unexpected rule kind: " + buildRule.Kind())
	}
}

func setDeps(
	runConfig *config.Config,
	buildRule *rule.Rule,
	attributeName string,
	ruleIndex *resolve.RuleIndex,
	currentRuleLabel label.Label,
	imports map[ImportStatement]interface{},
) {
	depSet := resolveImports(
		runConfig,
		ruleIndex,
		currentRuleLabel,
		imports,
	)
	if len(depSet) == 0 {
		return
	}

	deps := []label.Label{}
	for dep := range depSet {
		deps = append(deps, dep)
	}

	slices.SortFunc(deps, func(a, b label.Label) int {
		return strings.Compare(a.String(), b.String())
	})
	buildRule.SetAttr(attributeName, deps)
}

func resolveImports(
	runConfig *config.Config,
	ruleIndex *resolve.RuleIndex,
	currentRuleLabel label.Label,
	imports map[ImportStatement]interface{},
) map[label.Label]interface{} {
	deps := map[label.Label]interface{}{}

	for importStatement := range imports {
		if importStatement.ImportPath[0] != '.' &&
			importStatement.ImportPath[0] != '/' &&
			!strings.HasPrefix(importStatement.ImportPath, "@vx") {
			for _, dep := range resolveNodeModuleImport(
				runConfig, importStatement, currentRuleLabel,
			) {
				deps[dep] = nil
			}
			continue
		}

		matches := ruleIndex.FindRulesByImport(
			importStatement.ImportSpec,
			languageName,
		)
		for _, match := range matches {
			if match.IsSelfImport(currentRuleLabel) {
				continue
			}

			deps[match.Label] = nil
		}
	}

	return deps
}

func resolveNodeModuleImport(
	runConfig *config.Config,
	importStatement ImportStatement,
	currentRuleLabel label.Label,
) []label.Label {
	deps := []label.Label{}

	moduleNameParts := strings.Split(importStatement.Imp, "/")
	if moduleNameParts[0][0] == '@' {
		moduleNameParts = moduleNameParts[0:2]
	} else {
		moduleNameParts = moduleNameParts[0:1]
	}

	packageConfig, ok := runConfig.Exts[languageName].(*tsPackageConfig)
	if !ok {
		panic("ts_package : resolve : unable to retrieve config")
	}

	npmPackageName := path.Join(moduleNameParts...)

	_, isDependency := packageConfig.packageJson.Dependencies[npmPackageName]
	_, isDevDependency := packageConfig.packageJson.DevDependencies[npmPackageName]
	isNodePackage := npmPackageName == "node" ||
		strings.HasPrefix(npmPackageName, "node:")

	if (isDependency || isDevDependency) && !isNodePackage {
		deps = append(deps, label.Label{
			Repo: currentRuleLabel.Repo,
			Name: path.Join("node_modules", npmPackageName),
		})
	}

	if internalTypesTarget, exists := internalTypeDefinitionTargets[moduleNameParts[0]]; exists {
		deps = append(deps, internalTypesTarget)
	}

	return deps
}
